(ns mabasic\json\json
  (:use Arokettu\Bencode\Bencode :as Bencode)
  (:use Arokettu\Bencode\Exceptions\InvalidArgumentException) # TODO
  (:use \JsonException)
  (:require phel\json :as json)
  )

(defn valid-key?
  "Checks if `v` is a valid JSON key or can be converted to a JSON key."
  [v]
  (or (int? v) (float? v) (symbol? v) (keyword? v) (string? v)))

(declare encode-value [x])

(defn- encode-value-iterable [x]
  (let [arr (php/array)]
    (foreach [k v x]
      (when-not (valid-key? k)
        (throw (php/new JsonException "Key can only be an integer, float, symbol, keyword or a string.")))
      (php/aset arr (encode-value k) (encode-value v)))
    arr))

(defn encode-value
  "Convert a Phel data type to a 'json compatible' value."
  [x]
  (cond
    (php/is_iterable x) (encode-value-iterable x)
    (symbol? x) (name x)
    (keyword? x) (name x)  # TODO should use str to keep keyword recognizable from strings (?)
    (float? x) (str x)     #      see clojure for reference
    true x))

(defn encode
  "Returns the JSON representation of a value."
  [value & [{:flags flags :depth depth}]]
  (let [flags (or flags 0)  ## TODO remove params
        depth (or depth 512)]
    (when (php/is_resource value) (throw (php/new \InvalidArgumentException "Value can be any type except a resource.")))
    (when-not (int? flags) (throw (php/new \InvalidArgumentException "Flags must be an integer.")))
    (when-not (int? depth) (throw (php/new \InvalidArgumentException "Depth must be an integer.")))
    (when-not (> depth 0) (throw (php/new \InvalidArgumentException "Depth must be greater than zero.")))
    (php/:: Bencode (encode (encode-value value)))))

(defn decode-value  # TODO rename
  "Convert a json data structure to a 'phel compatible' value."
  [x]
  (cond
    (indexed? x) (for [v :in x] (decode-value v))
    (php-array? x) (let [hashmap (transient {})]
                     (foreach [k v x]
                       (put hashmap (keyword k) (decode-value v)))
                     (persistent hashmap))
    true x))

(defn decode
  "Decodes a JSON string."
  [json & [{:flags flags :depth depth}]]
  (let [flags (or flags 0)
        depth (or depth 512)]
    (when-not (string? json) (throw (php/new JsonException "Json must be a string.")))
    (when-not (int? flags) (throw (php/new JsonException "Flags must be an integer.")))
    (when-not (int? depth) (throw (php/new JsonException "Depth must be an integer.")))
    (when-not (> depth 0) (throw (php/new JsonException "Depth must be greater than zero.")))
    (php/:: Bencode (decode (decode-value json)))))

(comment
  (encode [123 345 "asfd" {:foo (set :asdf 123 "FOO")}])
  (decode "li123ei345e4:asfdd3:fool4:asdfi123e3:FOOeee")
  ## TODO (out): <PHP-Array [123, 345, asfd, Printer cannot print this type: ArrayObject]>
  ##             does phel\json behave like this also?

  (json/encode [123 345 "asfd" {:foo (set :asdf 123 "FOO")}])
  (json/decode "[123,345,\"asfd\",{\"foo\":[\"asdf\",123,\"FOO\"]}]")
  ## (out): [123 345 asfd {:foo [asdf 123 FOO]}]

  ## hash-map key string becomes keyword
  (-> (json/decode "[123,345,\"asfd\",{\"foo\":[\"asdf\",123,\"FOO\"]}]")
      peek keys first type)  # => :keyword

  )
